CUNCCURENCY - MULTIPLY NSTRUCTION EXECUTED AT A SAME TIME BY DIVIDING PROCESS INTO THREADS(SUBPROCESS ) AND PERFORMING PARALLELY 
THESE THREADS ARE INDEPENDENTLY AND WORK PARALLELLY (NOT SEQUENCLLY ) SO THEIR IS NO DELAY .

//HOW EACH THREAD GET ACCESS TO CPU :-
HAAR THREAD KA APNA PROGRAM COUNTER AND TCP (THREAD CONTROLLING PROTOOCOL) , OS FETCH THE INSTRUCTION AND USS PATICULAR 
PROGRAM KE ACCORDING KON TCP ME KON SA INSTRUCTION LIKHI H UNHE EXECUTE KRTA H

*CONTEXT SWITCHING IN TREAD AS WELL OS EK THREAD KE CONTEXT KO SAVE KRTA H OR DUSRE KE CONTEXT 
SWITCHING KO RETRIVE KRTA H WITHIN  SAME PROCESS
CONTEXT SWICHING IS FAST (OVERHAED CHHOTA H ) COZ WE DON'T HAVE TO SWITCH THE MEMORY SPACE HERE 
CACHE KO RESET KRNE KI JRURT NI H)

*IN SINGLE CPU MULTI THREADING IS BENIFICIAL - NO COZ PARALLIZIM NOT ACHIVE COZ CPU IS ONE 

*MEMEORY ALLOCATION IN CASE OF MULTI THREADING IS STACK 1 -> STACK 2-> ....STACK N -> HEAP -> DATA -> TEXT 

*BENIFITS OF MULTI THREADING 
RESPONIVENESS , RESOURCE SHARING (NO COMMUNICATION GAP) , ECONOMICAL , BETTER UTILIZES MUTIPLR CPUS , FAST EXECUTION 

------->CREATICAL SECTION PROBLRM - CODE KA EK AAISA HISSA JAHA PE MULTIPLE CODE 
AAKESATH  KAM KRRHI H COZ IT'S AN SHARED RESOURCE DATA UPDATION IS CRETICAL THEIR
COUNT++ ----- TEMP = COUNT + 1 -----COUNT = TEMP

T1 -> LOCKED IN CS ->  T2 , T3 WAITING -> WASTING THE CPU CYCLE 
RACE CONDITION- DAATA INCOSISITENCE WHEN TWO OR MORE THREAD ACCESS SHARE DATA AND THEY TRY TO CHANGE IT, CONTEXT SWITCHIGN IN MULTI THREADING 
//SOLUTION OF RACE CONDITION
1.ATOMIC VARIABLE - WHEN ENTIR EXECUTION TAKE ONE CPU CYCLE 
2.MUTUAL EXCLUSION ( SEQUENTIAL EXECUTION)
//SOLUTION OF CRETICAL SECTION HAS 3 CONDITIONS 
MUTUAL EXCLUSION - 
PROGRESS - EQUAL OPPORTUNITY HINA CHIYE SBE PS
BOUNDED WAITING - LIMITED TIME BOUND HONA CHIYE USKE BAAD DUSRI THREAD JAA SKTI H 


 WE USE ONR FLAG FOR CS FOR MUTUAL EXCLUSION ONLY NOT PROGRESS 

IMPROVED SOLUTION OF SINGLE FLAG IS PETERSSION SOLUTION - POSSIBLR FOR TWO THREADS
FOR 2 THREADS ONLY
FLAG[2] //0/1                             FLAG[2]
WHILE(1) {                                 WHILE(1){
TURN = 1 ;
FLAG[0] = T ;
WHILE(TURN == 1 && FLAG[1] == T ){
  CS
FLAG[0] = F ; }

LOCKS HELPS IN THREAD SYNCHRONOZISATION
//LOCK DISADVANTAGES -
CONTENTION - T1 INSIDE THEN T2 AND T3 ARE WAITING WITH CPU CYCLE CONSUMPTION 
DEADLOCK - T1 AND T2 TWO THREAD AND T1 ALLOCATED WITH R1 AND T2 ALLOCATED WITH R2 PAR YE AAGE KAM TAB TAK NI KRSKTE
JAB TAK R1 KO T2 OR R2 KO T1 NI MIL JATA SO PROCESS GOT DEAD LOCK IN THIS CASE THEY NEVER GOT FREE  
DEBUGGING - UNEXPECTED PROBLEM (IN PARALLEL )
STARVATION - LOW PRIVORITY THREAD AQUIRED LOCK IN  CS AND HIGH PRIORITY ARISES THEN IT ALSO HAS TO STARVE UNTILL THAT LOW PRIORITY GOT FINISHED


BUSY WAITING - T1 -> LOCKED IN CS ->  T2 , T3 WAITING -> WASTING THE CPU CYCLE 





