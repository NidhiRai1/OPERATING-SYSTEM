CUNCCURENCY - MULTIPLY NSTRUCTION EXECUTED AT A SAME TIME BY DIVIDING PROCESS INTO THREADS(SUBPROCESS ) AND PERFORMING PARALLELY 
THESE THREADS ARE INDEPENDENTLY AND WORK PARALLELLY (NOT SEQUENCLLY ) SO THEIR IS NO DELAY .

//HOW EACH THREAD GET ACCESS TO CPU :-
HAAR THREAD KA APNA PROGRAM COUNTER AND TCP (THREAD CONTROLLING PROTOOCOL) , OS FETCH THE INSTRUCTION AND USS PATICULAR 
PROGRAM KE ACCORDING KON TCP ME KON SA INSTRUCTION LIKHI H UNHE EXECUTE KRTA H

*CONTEXT SWITCHING IN TREAD AS WELL OS EK THREAD KE CONTEXT KO SAVE KRTA H OR DUSRE KE CONTEXT 
SWITCHING KO RETRIVE KRTA H WITHIN  SAME PROCESS
CONTEXT SWICHING IS FAST (OVERHAED CHHOTA H ) COZ WE DON'T HAVE TO SWITCH THE MEMORY SPACE HERE 
CACHE KO RESET KRNE KI JRURT NI H)

*IN SINGLE CPU MULTI THREADING IS BENIFICIAL - NO COZ PARALLIZIM NOT ACHIVE COZ CPU IS ONE 

*MEMEORY ALLOCATION IN CASE OF MULTI THREADING IS STACK 1 -> STACK 2-> ....STACK N -> HEAP -> DATA -> TEXT 

*BENIFITS OF MULTI THREADING 
RESPONIVENESS , RESOURCE SHARING (NO COMMUNICATION GAP) , ECONOMICAL , BETTER UTILIZES MUTIPLR CPUS , FAST EXECUTION 

------->CREATICAL SECTION PROBLRM - CODE KA EK AAISA HISSA JAHA PE MULTIPLE CODE 
AAKESATH  KAM KRRHI H COZ IT'S AN SHARED RESOURCE DATA UPDATION IS CRETICAL THEIR
COUNT++ ----- TEMP = COUNT + 1 -----COUNT = TEMP

T1 -> LOCKED IN CS ->  T2 , T3 WAITING -> WASTING THE CPU CYCLE 
RACE CONDITION- DAATA INCOSISITENCE WHEN TWO OR MORE THREAD ACCESS SHARE DATA AND THEY TRY TO CHANGE IT, CONTEXT SWITCHIGN IN MULTI THREADING 
//SOLUTION OF RACE CONDITION
1.ATOMIC VARIABLE - WHEN ENTIR EXECUTION TAKE ONE CPU CYCLE 
2.MUTUAL EXCLUSION ( SEQUENTIAL EXECUTION)
//SOLUTION OF CRETICAL SECTION HAS 3 CONDITIONS 
MUTUAL EXCLUSION - 
PROGRESS - EQUAL OPPORTUNITY HINA CHIYE SBE PS
BOUNDED WAITING - LIMITED TIME BOUND HONA CHIYE USKE BAAD DUSRI THREAD JAA SKTI H 


 WE USE ONR FLAG FOR CS FOR MUTUAL EXCLUSION ONLY NOT PROGRESS 

IMPROVED SOLUTION OF SINGLE FLAG IS PETERSSION SOLUTION - POSSIBLR FOR TWO THREADS
FOR 2 THREADS ONLY
FLAG[2] //0/1                             FLAG[2]
WHILE(1) {                                 WHILE(1){
TURN = 1 ;
FLAG[0] = T ;
WHILE(TURN == 1 && FLAG[1] == T ){
  CS
FLAG[0] = F ; }

LOCKS HELPS IN THREAD SYNCHRONOZISATION
//LOCK DISADVANTAGES -
CONTENTION - T1 INSIDE THEN T2 AND T3 ARE WAITING WITH CPU CYCLE CONSUMPTION 
DEADLOCK - T1 AND T2 TWO THREAD AND T1 ALLOCATED WITH R1 AND T2 ALLOCATED WITH R2 PAR YE AAGE KAM TAB TAK NI KRSKTE
JAB TAK R1 KO T2 OR R2 KO T1 NI MIL JATA SO PROCESS GOT DEAD LOCK IN THIS CASE THEY NEVER GOT FREE  
DEBUGGING - UNEXPECTED PROBLEM (IN PARALLEL )
STARVATION - LOW PRIVORITY THREAD AQUIRED LOCK IN  CS AND HIGH PRIORITY ARISES THEN IT ALSO HAS TO STARVE UNTILL THAT LOW PRIORITY GOT FINISHED


BUSY WAITING - T1 -> LOCKED IN CS ->  T2 , T3 WAITING -> WASTING THE CPU CYCLE 
BETTER VERSION OF THTREAD SYNCHRONOZISATION THROUGH NO WASTAGE OF CPU CYCLE IS -

CONDITIONAL 
CONDITIONAL VARIABLE USE LOCK AND IT HAS TWO METHOD WAITING FOR SIGNAL DUE TO THIS NOT WASTING CPU CYCLE AND SIGNAL
CONDITIONAL VARIABLE IS BETTER WAY NO VISIBILITY NO WASTAGE OF CPU CYCLE


//SEMAPORES -INTEGER VALUE (ALWATS > 0)- MULTIPLE INSTANCES OF SINGLE RESOURCES WITH THEIR MULTIPLE THREAD CAN ENTER THE CS RESOURCE 
AND WHEN VARIABLE == 0 THEN  WAIT TILL THEY GOT EXECUTED  AND UNTILL THEN NO OTHER THREAD APLLY THEIR LOCKS (NOT ALLOWED TO ENTER)
LET'S T1 GOT EXECTED THE VAR == 1THEN OTHER THREAD GET THAT RESOURCE FOR EECUTION

N > 2 CONTINUES SEMAPHORES AND N = 1 THEN BINARY SEMAPHONE




//producer and comsumer problem - ek thread producer which produce any data and consumer has a thread who consume 
jab producer hoto consumer disturbe na kre aake ( producer produce in empty slot na dconsumer consume from filed slot)

//problem
1.cretical section me race condition na occur ho (they are sinchronised)
2.producer must not insert when buffer is full 
3.consumer not pick when buffer is empty

//solution through semaphre 
*mutex (binary semaphore) - used to accquire look on buffer 
*empty (counting sema phore) - track empty slot (initial value = n)
*full (continous semaphore) - track field slot (initial value = 0)


//read and write problem - reader > 1 (no issue ) &&&&&&&&& writer > 1 (crete race /inconsistent condition )
but writer is writing then reader is not allowed to read then also chances of readign inconsistent data , only 1 write in CS ta a time 

//SOLUTION THROUGH SEMAPHORES
WHAT WE USE
*MUTEX (BINARY SEMAPHORE)- USE TO INSURE MUTUAL EXCLUSION ,WHEN READ COUNT IS UPDATED , NO. TWO THREADS MODIFY READ COUNT ATA 
SAME TIME
*WRT VARIABLE (BINARY SEMAPHORES) - COMMON FOR BOTH READ AND WRITE FOR SINCHRONISED WAY OF DATA ACCESS B/W READ AND WRITE
*READ COUNT R.C (INTEGER INITIALIZED WITH 0)


//CODE FOR READ AND WRITE








//DINING PHILOSHPHER PROBLEM-

EACH FORK = BINARY SEMAPHORK (ARR OF INITIAL VALUE 0 , LENTH - NO. OF FOLKS)
ASSUME PHILOSPHER =  PROCESS &&& FORKS = RESOURCE

ACQUIRE AND RELEASE 
BUT IF EACH PHILOSPHER GRAB THEIR LEFT OR RIGHT FORK THEN DEADLOCK ACCURE COZ THEY ARE 
WAITING FIR OTHER FORK TO GET FREE WHICH WON'T HAPPEN 

