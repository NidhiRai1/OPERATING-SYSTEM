//VIRTUAL MEMORY MANGMENT - WE HAVE FIXED PHYSICAL MEMORY AND WE HAVE DISK *I T , 2T)
WE LOADED THE NEEDED PAGES IN THE FRAM AND LEFT OUT PAGES OF PROGRAM WHICH ARE NOT IN USE KEPT IT IN RESERVE AREA OF DISK(BHUT BADHI H)
CALLED SWAP SPACE AND THESE PAGES ARE IN READY TO USE CONDITION IF USER ASK FIR IT THEN OS GETS A SIGNAL TO LOAD IT IN RAM(FRAM)

RAM + SWAP AREA = VIRTUAL MEMORY
//ADVAMTAGES OF VIRTUAL MEMORY :-
1.USER GETS ANA IDEA THAT THYE CAN RUN MULTIPLR PROGRAM AT A TIME
2.CPU UTILIZATION

//DEMAND PAGES - ONRE OF THE WAYS OF APPLING VIRTUAL MEMORY PAGES OF THE PROCESS WHICH ARE LESS USE STORE IN THE SECONDARY MEMMORY AND GET RELOADED IN THE RAM 
//DEMAND SWAPPING WORKS -
1. WHEN PROCESS SWAP THEN IT'S PAGER DUTY TO CHECK WHICH PAGES ARE IN USE
2.IT AVOID READING THOSE PAGES THAT WILL NOT BE USE ANYWAY
3.SO IT DECREASE THE SWAP TIME AND PHYSICAL MEMORY NEEDED
4.VALID-INVALID BIT = 1 THEN ASSOCIATED  PAGE IS VALID AND IN THE MEMORY
VALID - INVALID BIT = 0 THEN EITHER ASSOCIATE PAGE IS INVALID OR CURRENTLY IN THE DISK

//WHAT HAPPEN WHEN A PROCESS TRY TO ACCESS THE PAGE NOT IN THE MEMORY CALLED PAGE FAULT 
FROM THE NOTES 

//PURE DEMAND PAGING - IN EXTREAM CASES WE PUT ALL THE PROCESS OF THE PAGES IN THE SWAP AREA NON IN THE RAM WHEN THE DEMAND OCCUR THEN THEIR 
IS A INTRUPT GENERATED-----PAGE FAULT COZ OF NO PAGE IN THE MEMORY SO CALL GOES FROM OS INTO THE SWAP AREA AND THE DEMANDED PAGES ARE FILLED IN THE RAM

//ADVANTAGES OF VIRTUAL MEMORY:-
1.DEGREE OF MULTI PROGRAMMING WILL HIGH COZ OF DIVIDIMH PROCESSES INTO MULTIPLE PAGES
2.USER CAN RUN LARGE APPS WITH LESS REAL PHYSICAL ADDRESS

//DISADVANTAGES OF VIRTUAL SWAPPING :-
1.SYSTEM BECOME SLOWER AS SWAPPING TAKES TIME
//LAZY PAGER - RATHER THAN SWAPING THE ENTORE PROCESS INTO MEMORY WE USE LAZY SWAPPER MEVER SWAP THE PAGES UNLESS THE PAGE WILL BE NEEDED

//PAGE REPLACEMENT ALGORITHUM - YE DHOOMDHNE KE LIYE KI RAM SE KONSE PAGE KO SWAP OUT KRU KI SWAP AREA SE PAGE KO SWAP 
IN KRSKTU WHEN THE PAGE FAULT OCCURSWE NEED THIS ALLOGRITHUM
1.FIFO (FIRST IN FISRT OUT ) :- JO SBSE PHLE ALLOCATED HUAA THAA RAM SE USSE SWAP OUT KRO AFTER THE PAGE FAULT OCCUR
    AND EVERY FAULT CAUSE A OVERHEAD CALLED PAGE FAULT SERVICE TIME WHOES ACCESS TIME IS HUGE
OUR AIM TO FIND LOW PAGE FAULT TIME THEN LESS OVERHEAD AND FASTER ALOGRITHUM 
//ADVANTAGES
EASY TO IMPLEMENT
VARIABLE PERFORMATION
//DISADVANTAGES
MORE OVERHAED AND SLOWER ALGORITHUM
BELADY'S ANOMOLY IS PRESENT - LIEK IN GENERAL WITH INCREASE IN NO. OF FRAMES PAGE FAULT DECRESES BUT HERE IT WON'T FOLLOW THIS TREND IN SOME CASES LIKR LRU
2.OPTIMAL ALOGRITHU - FIND THE PAGE THAT IS NEVER REFERED IN THE FUTURE IF SAY SO THEN REPLACE THAT PAGE WITH NEW PAGE
AND IF NOT THEN FIND A PAGE THAT IS FA REFERRED FARTHEST IN FUTURE , RELACE THAT PAGE WITH NEW PAGE , BUT IT IS HYPOTHETICAL
IT HAS THE LOWEST PAGE FAULT 

3.LEAST RECENTLY USED(LRU) - BASED ON PAST VALUE WE PREDICT IT HAS LOW VALUE OF PAGE FAULT BUT Greater then optimised algorithum
  with the help of stack

//threshing - high paging activity and it spend more time in searching the page fault the executing the program
before threasing with inc. in degree of multi programming the cpu utilization inc. 
in case of threasing
less degree of multi programming -> less page fault -> more cpu utilization -> less threasing

//how to handle threasing -
1.WORKING SET MODEL - LOAD THE CURRENT LOCALITY PAGE FRAMES ARE THEIR SO LOW PAGE FAULT
2. PAGE FAULT FREQUESNCY - IF THE GRAPH BETWEEN NO. OF PAGE FAULT AND NO. OF FRAMESLIES ABOVE THE UPPER BOUND THEN IINC. THE NO. 
OF FRAME AND BRING IT IN BETWWEN UPPER AND LOWER BOUND BUT IF THIS GOES DOWN THEN THE LOWER BOUND THE DEC. THE FRAM NO. OF EACH PROCESS









